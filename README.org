[[./spacemacs.svg]]
* Table of Contents                                                      :TOC:
- [[#about][About]]
  - [[#note-for-making-elisp-blocks][Note for making Elisp Blocks]]
- [[#setup][Setup]]
  - [[#turn-off-garbage-collection][Turn off garbage collection]]
  - [[#lets-make-the-emacs-start-up-run-fast][Let's make the Emacs start up run fast]]
  - [[#package-repositories][Package repositories]]
  - [[#personal-information][Personal information]]
- [[#tent-pole][Tent Pole]]
  - [[#use-package][use-package]]
  - [[#org-mode][Org Mode]]
  - [[#langtool][Langtool]]
  - [[#eshell][EShell]]
  - [[#magit][Magit]]
- [[#look-and-feel][Look and Feel]]
  - [[#window][Window]]
  - [[#font][Font]]
  - [[#misc][Misc]]
  - [[#smooth-scrolling][Smooth scrolling]]
  - [[#theme][Theme]]
  - [[#modeline][Modeline]]
  - [[#line-numbers][Line Numbers]]
  - [[#rainbow-delimiters][Rainbow delimiters]]
  - [[#dired][dired]]
  - [[#diminish][Diminish]]
- [[#os-specific][OS Specific]]
  - [[#macos][MacOS]]
  - [[#windows][Windows]]
- [[#navigating][Navigating]]
  - [[#uniquify][Uniquify]]
  - [[#dired-1][Dired+]]
  - [[#recentf][Recentf]]
  - [[#projectile][Projectile]]
  - [[#minibuffer-completion][Minibuffer completion]]
  - [[#treemacs][Treemacs]]
  - [[#treemacs-pojectile][Treemacs Pojectile]]
  - [[#avy][Avy]]
- [[#editing][Editing]]
  - [[#multiple-cursors][Multiple Cursors]]
  - [[#newline-and-indent][Newline and indent]]
  - [[#truncate-lines][Truncate lines]]
  - [[#highlight-current-line][Highlight current line]]
  - [[#highlight-matching-parens][Highlight matching parens]]
  - [[#no-tabs][No tabs]]
  - [[#set-base-indent][Set base indent]]
  - [[#save-place-in-file][Save place in file]]
  - [[#parens-balancing][Parens Balancing]]
  - [[#hungry-delete][Hungry Delete]]
  - [[#code-folding][Code Folding]]
  - [[#dash-at-point][Dash At Point]]
  - [[#undo-tree][Undo-tree]]
  - [[#backups][Backups]]
  - [[#whitespace][Whitespace]]
- [[#syntax-and-error-checking][Syntax and Error checking]]
  - [[#flycheck-pos-tip][Flycheck pos-tip]]
  - [[#flycheck][Flycheck]]
- [[#code-completion][Code Completion]]
  - [[#semantic][Semantic]]
  - [[#company][Company]]
  - [[#lsp-mode][LSP-Mode]]
- [[#setup-1][Setup]]
  - [[#csslesssass][CSS/LESS/SASS]]
  - [[#cc][C/C++]]
  - [[#lisp][Lisp]]
  - [[#elisp][Elisp]]
  - [[#clojure][Clojure]]
  - [[#javascript][JavaScript]]
  - [[#html][HTML]]
  - [[#ruby][Ruby]]
  - [[#rust][Rust]]
  - [[#go][Go]]
  - [[#json][JSON]]
  - [[#docker][Docker]]
  - [[#markdown][Markdown]]
  - [[#lua][Lua]]
  - [[#powershell][Powershell]]
  - [[#terraform][Terraform]]
  - [[#yaml][YAML]]
  - [[#ssh][SSH]]
  - [[#text-modes][Text modes]]
- [[#communication][Communication]]
  - [[#slack][Slack]]
- [[#misc-1][Misc]]
  - [[#fuzzy-matching][Fuzzy matching]]
  - [[#woman][Woman]]
  - [[#ido-completing-read][ido-completing-read]]
  - [[#asynchronous-framework][Asynchronous framework]]
  - [[#profiling][Profiling]]
  - [[#dired-2][dired+]]
  - [[#http-client][http client]]
- [[#custom-functions][Custom Functions]]
  - [[#resize-font-size][Resize font size]]
  - [[#scroll-the-buffer][Scroll the buffer]]
  - [[#tangle-and-compile-init-file][Tangle and Compile init file]]
  - [[#run-current-file][Run Current File]]
  - [[#eval-and-replace][Eval and Replace]]
  - [[#replace-tabs][Replace tabs]]
  - [[#find-unused-functions-in-javascript][Find unused functions in JavaScript]]
  - [[#enable-paredit-or-parinfer][Enable Paredit or Parinfer]]
  - [[#renema-buffer-and-file][Renema buffer and file]]
  - [[#post-from-any-buffer-to-slack-with-emacs][Post from any buffer to Slack with Emacs]]
  - [[#turn-back-on-file-name-handler-alist][Turn back on file-name-handler-alist]]
  - [[#playground][Playground]]

* About
  "Instead of imagining that our main task is to instruct a computer what to do, let us concentrate rather on explaining to human beings what we want a computer to do." - Donald Knuth
  This Config file is inspired by:
  + [[http://pages.sachachua.com/.emacs.d/Sacha.html]] 
  + [[http://thewanderingcoder.com/2015/02/literate-emacs-configuration/]]
** Note for making Elisp Blocks
I've forgotten this before so this seems like the perfect place to put it but ~C-c C-v d~ or ~org-babel-demarcate-block~ creates a code-block for the language of your choice
* Setup
** Turn off garbage collection
This sets the garbage collection threshold to 100mb
Reset garbage collection to emacs default after 5s
#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold 1000000000)
(run-with-idle-timer
 5 nil
 (lambda ()
   (setq gc-cons-threshold 10000000)
   (message "gc-cons-threshold restored to %S"
            gc-cons-threshold)))
#+END_SRC

** Let's make the Emacs start up run fast
#+BEGIN_SRC emacs-lisp
(setq
 lexical-binding t
 load-prefer-newer t)
#+END_SRC

Some recommendations by https://github.com/hlissner/doom-emacs/wiki/FAQ#how-is-dooms-startup-so-fast
#+BEGIN_SRC emacs-lisp
(defvar doom--file-name-handler-alist file-name-handler-alist)
(setq file-name-handler-alist nil)
#+END_SRC

** Package repositories
Define custom package repositories besides ELPA. If I am being honest with myself, Marmalade and Tromey are probably not necessary repositories.
#+BEGIN_SRC emacs-lisp :tangle
  (require 'package)
  (setq package-user-dir "~/.emacs.d/elpa")
  (setq package-archives
        '(("gnu" . "https://elpa.gnu.org/packages/")
          ("melpa" . "http://melpa.org/packages/")
          ("marmalade" . "http://marmalade-repo.org/packages/")
          ("tromey" . "http://tromey.com/elpa/")))
  (package-initialize)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq package-user-dir "~/.emacs.d/elpa")
  (setq package-archives
        '(("gnu" . "https://elpa.gnu.org/packages/")
          ("melpa" . "http://melpa.org/packages/")
          ("org" . "https://orgmode.org/elpa/")
          ("tromey" . "http://tromey.com/elpa/")))
#+END_SRC

** Personal information
#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Justin Barclay"
        user-mail-address "justinbarclay@gmail.com")
#+END_SRC
* Tent Pole
For big emacs packages, that help define the experience of Emacs itself
** use-package
I use Jon Wiegley's [[https://github.com/jwiegley/use-package][use-package]] for dependency management.
Let's bootstrap use-package so it can download everything else as we need it.
*** Byte Compile Init file
#+BEGIN_SRC emacs-lisp :tangle
(setq package-enable-at-startup nil)
  (eval-when-compile
    (package-initialize)
    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package)))
#+END_SRC
*** Don't byte compile init file
Boot strap use-package. Because we're running package initalize ourselves, we can turn it off when emacs wants to run it later in the startup process
#+BEGIN_SRC emacs-lisp
  (setq package-enable-at-startup nil
        package--init-file-ensured t)
  ;; (package-initialize)
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
#+END_SRC
*** TODO Make better consolidate and explain what is going on in use-package
*** A macro to increase emacs load times
This macro is pulled off this commit
https://github.com/jwiegley/use-package/pull/487/commits
Further reading: https://github.com/nilcons/emacs-use-package-fast
#+BEGIN_SRC emacs-lisp
  (defmacro use-package-with-elpa ()
    "Set up use-package to optimal usage with package.el.

  For full documentation on the meaning and usage of this, please
  consult the README file that came with this file at the section
  called `Byte-compiling with Package.el'."
    '(progn
       ;; Disable package initialize after us.  We either initialize it
       ;; anyway in case of interpreted .emacs, or we don't want slow
       ;; initizlization in case of byte-compiled .emacs.elc.
       (setq package-enable-at-startup nil)
       ;; Set use-package-verbose to t for interpreted .emacs,
       ;; and to nil for byte-compiled .emacs.elc.
       (eval-and-compile
         (setq use-package-verbose (not (bound-and-true-p byte-compile-current-file))))
       ;; Add the macro generated list of package.el loadpaths to load-path.
       (mapc (lambda (add) (add-to-list 'load-path add))
             (eval-when-compile
               (setq use-package-always-ensure t)
               (let ((package-user-dir-real (file-truename package-user-dir)))
                 ;; The reverse is necessary, because outside we mapc
                 ;; add-to-list element-by-element, which reverses.
                 (nreverse (apply #'nconc
                                  ;; Only keep package.el provided loadpaths.
                                  (mapcar (lambda (path)
                                            (if (string-prefix-p package-user-dir-real path)
                                                (list path)
                                              nil))
                                          load-path))))))))
#+END_SRC

*** byte compile emacs and ignore package-initialize
#+BEGIN_SRC emacs-lisp
  (use-package-with-elpa)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (progn ;'use-package
    (require 'use-package)
    (setq use-package-always-ensure t)
    (setq use-package-verbose nil)
    (setq use-package-always-defer t)
    (setq use-package-enable-imenu-support t))
#+END_SRC

*** Using use-package
The plan is to use a copious amount of deferral to speed up emacs boot time.
+ Use the :init keyword to execute code before a package is loaded. It accepts one or more forms, up until the next keyword
+ :config can be used to execute code after a package is loaded. 
+ The :ensure keyword causes the package(s) to be installed automatically if not already present on your system (set (setq use-package-always-ensure t)
+ You can override package deferral with the :demand keyword. Thus, even if you use :bind, using :demand will force loading to occur immediately and not establish an autoload for the bound key.
+ In almost all cases you don't need to manually specify :defer t. This is implied whenever :bind or :mode or :interpreter is used. 
*** Debugging
The :disabled keyword can turn off a module you're having difficulties with, or stop loading something you're not using at the present time:
#+BEGIN_SRC emacs-lisp
  ;; (use-package ess-site                   
  ;;   :disabled
  ;;   :commands R)
#+END_SRC
When byte-compiling your .emacs file, disabled declarations are omitted from the output entirely, to accelerate startup times.
*** Benchmark-init
This is hidden here to load right after we have use-package to be able to benchmark startup
#+BEGIN_SRC emacs-lisp :tangle
  (use-package benchmark-init
    :demand t
    :init
    (benchmark-init/activate)
    :config
    ;; To disable collection of benchmark data after init is done.
    (add-hook 'window-setup-hook 'benchmark-init/deactivate))
#+END_SRC
** Org Mode
Org config used from https://github.com/zamansky/dotemacs/commit/0d1f8ad89ab3e69cb9320811c5ec63409880eadd
*** Org
#+BEGIN_SRC emacs-lisp
  (use-package org
    :bind
    (("C-c a" . org-agenda)
     ("C-c c" . org-capture)
     ("C-c C-v C-c" . jb/org-clear-results))
    :init
    (progn
      (global-unset-key "\C-c\C-v\C-c")
      (setq truncate-lines t
            global-company-modes '(not org-mode)))
    :config
    (progn
      (defun jb/org-clear-results ()
        (interactive)
        (org-babel-remove-result-one-or-many 't))
      (defun run-org-block ()
        (interactive)
        (save-excursion
          (goto-char
           (org-babel-find-named-block
            (completing-read "Code Block: " (org-babel-src-block-names))))
          (org-babel-execute-src-block-maybe)))
      (setq org-startup-truncated nil)
      (setq org-capture-templates
            '(("a" "Appointment" entry (file+headline  "~/Dropbox/orgfiles/gcal.org" "Appointments")
               "* TODO %?\n:PROPERTIES:\n\n:END:\nDEADLINE: %^T \n %i\n")
              ("l" "Link" entry (file+headline "~/Dropbox/orgfiles/links.org" "Links")
               "* %? %^L %^g \n%T" :prepend)))
      (setq org-agenda-files (list "~/Dropbox/orgfiles/gcal.org"))
      (org-babel-do-load-languages 'org-babel-load-languages
                                   '((shell . t)
                                     (js . t)
                                     (ruby . t)))
      (custom-set-variables
       '(org-directory "~/Dropbox/orgfiles")
       '(org-default-notes-file (concat org-directory "/notes.org"))
       '(org-export-html-postamble nil)
       '(org-hide-leading-stars t)
       '(org-startup-folded (quote overview))
       '(org-startup-indented t))))
#+END_SRC
*** Org-bullets
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :init
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC
*** Ob-Restclient
#+BEGIN_SRC emacs-lisp
  (use-package ob-restclient
    :init
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((restclient . t))))
#+END_SRC
*** Org-toc
After the installation, every time you’ll be saving an org file, the first headline with a :TOC: tag will be updated with the current table of contents.

To add a TOC tag, you can use the command org-set-tags-command (C-c C-q).

In addition to the simple :TOC: tag, you can also use the following tag formats:

    :TOC_2: - sets the max depth of the headlines in the table of contents to 2 (the default)
    :TOC_2_gh: - sets the max depth as in above and also uses the GitHub-style hrefs in the table of contents (this style is default). The other supported href style is ‘org’, which is the default org style.

You can also use @ as separator, instead of _.
#+BEGIN_SRC emacs-lisp
  (use-package toc-org
    :hook (org-mode-hook . toc-org-enable))

#+END_SRC
*** Org-re-reveal
Creating presentation using org mode and the web
#+BEGIN_SRC emacs-lisp
  (use-package org-re-reveal)
#+END_SRC
*** Custom Org Functions
These functions expand on the abilities of org-babel and ob-restclient mode and
as such need both of these modes loaded before they'll work.
#+BEGIN_SRC elisp
  ;; This is mostly a copy and pasted version of `org-babel-execute-src-block` but
  ;; it extracts the language parameter from being defined within the function
  ;; to a mandatory argument that needs to be passed in.
  (defun jb/org-babel-execute-src-block-with-lang (lang &optional arg info params)
    "Execute the current source code block by specifying the
  language the block should be executed with.
  Insert the results of execution into the buffer.  Source code
  execution and the collection and formatting of results can be
  controlled through a variety of header arguments.

  With prefix argument ARG, force re-execution even if an existing
  result cached in the buffer would otherwise have been returned.

  Optionally supply a value for INFO in the form returned by
  `org-babel-get-src-block-info'.

  Optionally supply a value for PARAMS which will be merged with
  the header arguments specified at the front of the source code
  block."
    (let* ((org-babel-current-src-block-location
            (or org-babel-current-src-block-location
                (nth 5 info)
                (org-babel-where-is-src-block-head)))
           (info (if info (copy-tree info) (org-babel-get-src-block-info))))
      ;; Merge PARAMS with INFO before considering source block
      ;; evaluation since both could disagree.
      (cl-callf org-babel-merge-params (nth 2 info) params)
      (when (org-babel-check-evaluate info)
        (cl-callf org-babel-process-params (nth 2 info))
        (let* ((params (nth 2 info))
               (cache (let ((c (cdr (assq :cache params))))
                        (and (not arg) c (string= "yes" c))))
               (new-hash (and cache (org-babel-sha1-hash info :eval)))
               (old-hash (and cache (org-babel-current-result-hash)))
               (current-cache (and new-hash (equal new-hash old-hash))))
          (cond
           (current-cache
            (save-excursion		;Return cached result.
              (goto-char (org-babel-where-is-src-block-result nil info))
              (forward-line)
              (skip-chars-forward " \t")
              (let ((result (org-babel-read-result)))
                (message (replace-regexp-in-string "%" "%%" (format "%S" result)))
                result)))
           ((org-babel-confirm-evaluate info)
            (let* ((result-params (cdr (assq :result-params params)))
                   ;; Expand noweb references in BODY and remove any
                   ;; coderef.
                   (body
                    (let ((coderef (nth 6 info))
                          (expand
                           (if (org-babel-noweb-p params :eval)
                               (org-babel-expand-noweb-references info)
                             (nth 1 info))))
                      (if (not coderef) expand
                        (replace-regexp-in-string
                         (org-src-coderef-regexp coderef) "" expand nil nil 1))))
                   (dir (cdr (assq :dir params)))
                   (default-directory
                     (or (and dir (file-name-as-directory (expand-file-name dir)))
                         default-directory))
                   (cmd (intern (concat "org-babel-execute:" lang)))
                   result)
              (unless (fboundp cmd)
                (error "No org-babel-execute function for %s!" lang))
              (message "executing %s code block%s..."
                       (capitalize lang)
                       (let ((name (nth 4 info)))
                         (if name (format " (%s)" name) "")))
              (if (member "none" result-params)
                  (progn (funcall cmd body params)
                         (message "result silenced"))
                (setq result
                      (let ((r (funcall cmd body params)))
                        (if (and (eq (cdr (assq :result-type params)) 'value)
                                 (or (member "vector" result-params)
                                     (member "table" result-params))
                                 (not (listp r)))
                            (list (list r))
                          r)))
                (let ((file (cdr (assq :file params))))
                  ;; If non-empty result and :file then write to :file.
                  (when file
                    ;; If `:results' are special types like `link' or
                    ;; `graphics', don't write result to `:file'.  Only
                    ;; insert a link to `:file'.
                    (when (and result
                               (not (or (member "link" result-params)
                                        (member "graphics" result-params))))
                      (with-temp-file file
                        (insert (org-babel-format-result
                                 result
                                 (cdr (assq :sep params))))))
                    (setq result file))
                  ;; Possibly perform post process provided its
                  ;; appropriate.  Dynamically bind "*this*" to the
                  ;; actual results of the block.
                  (let ((post (cdr (assq :post params))))
                    (when post
                      (let ((*this* (if (not file) result
                                      (org-babel-result-to-file
                                       file
                                       (let ((desc (assq :file-desc params)))
                                         (and desc (or (cdr desc) result)))))))
                        (setq result (org-babel-ref-resolve post))
                        (when file
                          (setq result-params (remove "file" result-params))))))
                  (org-babel-insert-result
                   result result-params info new-hash lang)))
              (run-hooks 'org-babel-after-execute-hook)
              result)))))))

  ;; generated-curl-command is used to communicate state across several function calls
  (setq generated-curl-command nil)

  (defvar org-babel-default-header-args:restclient-curl
    `((:results . "raw"))
    "Default arguments for evaluating a restclient block.")

  ;; Lambda function reified to a named function, stolen from restclient
  (defun gen-restclient-curl-command (method url headers entitty)
    (let ((header-args
           (apply 'append
                  (mapcar (lambda (header)
                            (list "-H" (format "%s: %s" (car header) (cdr header))))
                          headers))))
      (setq generated-curl-command
            (concat
             "#+BEGIN_SRC sh\n"
             "curl "
             (mapconcat 'shell-quote-argument
                        (append '("-i")
                                header-args
                                (list (concat "-X" method))
                                (list url)
                                (when (> (string-width entitty) 0)
                                  (list "-d" entitty)))
                        " ")
             "\n#+END_SRC"))))

  (defun org-babel-execute:restclient-curl (body params)
    "Execute a block of Restclient code to generate a curl command with org-babel.
  This function is called by `org-babel-execute-src-block'"
    (message "executing Restclient source code block")
    (with-temp-buffer
      (let ((results-buffer (current-buffer))
            (restclient-same-buffer-response t)
            (restclient-same-buffer-response-name (buffer-name))
            (display-buffer-alist
             (cons
              '("\\*temp\\*" display-buffer-no-window (allow-no-window . t))
              display-buffer-alist)))

        (insert (buffer-name))
        (with-temp-buffer
          (dolist (p params)
            (let ((key (car p))
                  (value (cdr p)))
              (when (eql key :var)
                (insert (format ":%s = %s\n" (car value) (cdr value))))))
          (insert body)
          (goto-char (point-min))
          (delete-trailing-whitespace)
          (goto-char (point-min))
          (restclient-http-parse-current-and-do 'gen-restclient-curl-command))
        generated-curl-command)))

  ;; Make it easy to interactively generate curl commands
  (defun jb/gen-curl-command ()
    (interactive)
    (jb/org-babel-execute-src-block-with-lang "restclient-curl"))
#+END_SRC

** Langtool
#+BEGIN_SRC elisp
  (use-package langtool
    :init
    (setq langtool-default-language "en-US")
    (setq langtool-java-bin "/usr/bin/java")
    (setq langtool-language-tool-jar "/usr/local/Cellar/languagetool/4.4/libexec/languagetool-commandline.jar"))
#+END_SRC


** EShell
#+BEGIN_SRC emacs-lisp
(use-package eshell
  :init
  (add-hook 'eshell-mode-hook
                   #'company-mode)
  :config
  (progn
    (eval-after-load 'esh-opt
      '(progn
         (require 'em-prompt)
         (require 'em-term)
         (require 'em-cmpl)
         (setenv "PAGER" "cat")
         (add-to-list 'eshell-visual-commands "ssh")
         (add-to-list 'eshell-visual-commands "htop")
         (add-to-list 'eshell-visual-commands "top")
         (add-to-list 'eshell-visual-commands "tail")
         (add-to-list 'eshell-visual-commands "vim")
         (add-to-list 'eshell-visual-commands "bower")
         (add-to-list 'eshell-visual-commands "npm")

         (add-to-list 'eshell-command-completions-alist
                      '("gunzip" "gz\\'"))
         (add-to-list 'eshell-command-completions-alist
                      '("tar" "\\(\\.tar|\\.tgz\\|\\.tar\\.gz\\)\\'"))))))
#+END_SRC
** Magit
#+BEGIN_SRC emacs-lisp
  ;; Magit is an Emacs interface to Git.
  ;; (It's awesome)
  ;; https://github.com/magit/magit
  (use-package magit
    :commands magit-get-top-dir
    :bind (("C-c g" . magit-status)
           ("C-c C-g l" . magit-file-log)
           ("C-c f" . magit-grep))
    :init
    (progn
      ;; magit extensions

      ;; make magit status go full-screen but remember previous window
      ;; settings
      ;; from: http://whattheemacsd.com/setup-magit.el-01.html
      (defadvice magit-status (around magit-fullscreen activate)
        (window-configuration-to-register :magit-fullscreen)
        ad-do-it
        (delete-other-windows))

      ;; Close popup when commiting - this stops the commit window
      ;; hanging around
      ;; From: http://git.io/rPBE0Q
      (defadvice git-commit-commit (after delete-window activate)
        (delete-window))

      (defadvice git-commit-abort (after delete-window activate)
        (delete-window))

      ;; these two force a new line to be inserted into a commit window,
      ;; which stops the invalid style showing up.
      ;; From: http://git.io/rPBE0Q
      (defun magit-commit-mode-init ()
        (when (looking-at "\n")
          (open-line 1)))

      (add-hook 'git-commit-mode-hook 'magit-commit-mode-init))
    :config
    (progn
      ;; restore previously hidden windows
          ;; major mode for editing `git rebase -i`
      (defadvice magit-quit-window (around magit-restore-screen activate)
        (let ((current-mode major-mode))
          ad-do-it
          ;; we only want to jump to register when the last seen buffer
          ;; was a magit-status buffer.
          (when (eq 'magit-status-mode current-mode)
            (jump-to-register :magit-fullscreen))))

      (defun magit-maybe-commit (&optional show-options)
        "Runs magit-commit unless prefix is passed"
        (interactive "P")
        (if show-options
            (magit-key-mode-popup-committing)
          (magit-commit)))

      (define-key magit-mode-map "c" 'magit-maybe-commit)

      ;; magit settings
      (setq
       ;; use ido to look for branches
       magit-completing-read-function  'ivy-completing-read
       ;; don't put "origin-" in front of new branch names by default
       magit-default-tracking-name-function 'magit-default-tracking-name-branch-only
       ;; open magit status in same window as current buffer
       magit-status-buffer-switch-function 'switch-to-buffer
       ;; highlight word/letter changes in hunk diffs
       magit-diff-refine-hunk t
       ;; ask me if I want to include a revision when rewriting
       magit-rewrite-inclusive 'ask
       ;; ask me to save buffers
       magit-save-some-buffers nil
       ;; pop the process buffer if we're taking a while to complete
       magit-process-popup-time 10
       ;; ask me if I want a tracking upstream
       magit-set-upstream-on-push 'askifnotset)))
#+END_SRC
*** Magit blame
#+BEGIN_SRC emacs-lisp
(use-package magit-blame
  :ensure nil
  :bind ("C-c C-g b" . magit-blame-mode))
#+END_SRC

* Look and Feel
** Window
*** Natural colouring from emacs chrome
#+BEGIN_SRC emacs-lisp
  (setq default-frame-alist '((ns-transparent-titlebar . t) (ns-appearance . 'nil)))
  (add-to-list 'default-frame-alist '(ns-appearance . dark))
#+END_SRC

*** Remove toolbar
#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
#+END_SRC
*** Remove title-barclay
#+BEGIN_SRC emacs-lisp :tangle
(setq default-frame-alist '((undecorated . t)))
#+END_SRC


*** Emacs should take focus when it launches
#+BEGIN_SRC emacs-lisp
(when (display-graphic-p) ; Start full screen
  (add-to-list 'default-frame-alist '(fullscreen . t))
  (x-focus-frame nil))
#+END_SRC

*** Don't show native OS scroll bars for buffers because they're redundant
#+BEGIN_SRC emacs-lisp
(when (fboundp 'scroll-bar-mode)
  (scroll-bar-mode -1))
#+END_SRC

*** Formatting window title
#+BEGIN_SRC emacs-lisp
(setq-default frame-title-format "%b (%f)")
#+END_SRC
** Font
#+BEGIN_SRC emacs-lisp
(set-face-attribute 'default nil
                    :family "Inconsolata for Powerline" :height 180 :weight 'normal)
#+END_SRC
** Misc
Don't pop up font menu
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "s-t") '(lambda () (interactive)))
#+END_SRC

No cursor blinking, it's distracting
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; These settings relate to how emacs interacts with your operating system
(setq ;; makes killing/yanking interact with the clipboard
 select-enable-clipboard t

 ;; I'm actually not sure what this does but it's recommended?
 select-enable-primary t

 ;; Save clipboard strings into kill ring before replacing them.
 ;; When one selects something in another program to paste it into Emacs,
 ;; but kills something in Emacs before actually pasting it,
 ;; this selection is gone unless this variable is non-nil
 save-interprogram-paste-before-kill t

 ;; Shows all options when running apropos. For more info,
 ;; https://www.gnu.org/software/emacs/manual/html_node/emacs/Apropos.html
 apropos-do-all t

 ;; Mouse yank commands yank at point instead of at click.
 mouse-yank-at-point t)
#+END_SRC

My name isn't "Tinker", so I don't need a bell.
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; Changes all yes/no questions to y/n type
(fset 'yes-or-no-p 'y-or-n-p)

;; shell scripts
(setq-default sh-basic-offset 2)
(setq-default sh-indentation 2)

;; No need for ~ files when editing
(setq create-lockfiles nil)

;; Go straight to scratch buffer on startup
(setq inhibit-startup-message t)
#+END_SRC
** Smooth scrolling

#+BEGIN_SRC emacs-lisp :tangle
(use-package smooth-scroll
  :config
  (smooth-scroll-mode 1)
  (setq smooth-scroll/vscroll-step-size 5))
#+END_SRC

** Theme
*** Dracula
#+BEGIN_SRC emacs-lisp
(use-package dracula-theme
  :demand t
  :config
  (load-theme 'dracula t))
#+END_SRC
** Modeline
*** Powerline
#+BEGIN_SRC emacs-lisp
  (use-package powerline
    :config
    ;;(powerline-center-theme)
    (setq powerline-default-separator 'wave))
#+END_SRC
*** Spaceline
#+BEGIN_SRC emacs-lisp
(use-package spaceline
  :config
  (require 'spaceline-config)
  (setq spaceline-byte-compile nil))
#+END_SRC
*** all-the-icons
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons)
#+END_SRC
*** Doom-modeline
#+BEGIN_SRC emacs-lisp
  (use-package doom-modeline
    :hook (after-init . doom-modeline-mode)
    :init
    (progn
      (setq doom-modeline-buffer-file-name-style 'relative-to-project)
      (setq doom-modeline-github nil)
      (custom-set-faces '(doom-modeline-eyebrowse ((t (:background "#cb619e"
                                                                   :inherit 'mode-line))))
                        '(doom-modeline-inactive-bar ((t (:background "#cb619e" :inherit 'mode-line))))
                        '(doom-modeline-bar ((t (:background "#cb619e" :inherit 'mode-line)))))))
#+END_SRC

** Line Numbers
As of Emacs 26.0 we have native, perfomant support for line numebrs
#+BEGIN_SRC emacs-lisp
(global-display-line-numbers-mode)
(set-default 'display-line-numbers-type 'visual)
(setq display-line-numbers-current-absolute t)
#+END_SRC
** Rainbow delimiters
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode)
    :config
     (custom-set-faces 
      '(rainbow-delimiters-depth-0-face ((t (:foreground "saddle brown"))))
      '(rainbow-delimiters-depth-1-face ((t (:foreground "dark orange"))))
      '(rainbow-delimiters-depth-2-face ((t (:foreground "deep pink"))))
      '(rainbow-delimiters-depth-3-face ((t (:foreground "chartreuse"))))
      '(rainbow-delimiters-depth-4-face ((t (:foreground "deep sky blue"))))
      '(rainbow-delimiters-depth-5-face ((t (:foreground "yellow"))))
      '(rainbow-delimiters-depth-6-face ((t (:foreground "orchid"))))
      '(rainbow-delimiters-depth-7-face ((t (:foreground "spring green"))))
      '(rainbow-delimiters-depth-8-face ((t (:foreground "sienna1"))))
      '(rainbow-delimiters-unmatched-face ((t (:foreground "black"))))))
#+END_SRC
** dired
#+BEGIN_SRC emacs-lisp
  (use-package dired
    :ensure nil
    :bind (:map dired-mode-map
                ("RET" . dired-find-alternate-file)
                ("a" . dired-find-file)))
#+END_SRC

** Diminish
#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :demand t
    :config (progn
              ;;            (diminish 'auto-revert-mode)
              ;;            (diminish 'outline-minor-mode)
              ;;            (diminish 'amd-mode)
              (diminish 'js2-refactor-mode)
              (diminish 'tern-mode)))
#+END_SRC

* OS Specific
** MacOS
In OS X, when Emacs is started from the GUI it inherits a default set of environment variables. Let's fix that.
Currently turned off due to debugging issues
#+BEGIN_SRC emacs-lisp :tangle
    (use-package exec-path-from-shell
      :if (eq system-type 'darwin)
      :demand t
      :init
      (progn
        (setq exec-path-from-shell-debug t))
      :config
      (exec-path-from-shell-initialize))
    ;;   ;; (exec-path-from-shell-copy-envs
    ;;   ;;  '("PATH" "RUST_SRC_PATH")))
#+END_SRC
** Windows
#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'windows-nt)
    (setq package-check-signature nil)
    (require 'gnutls)
    (add-to-list 'gnutls-trustfiles (expand-file-name "~/.cert/cacert.pm"))
    (setq explicit-shell-file-name "c:/windows/system32/bash.exe")
    (setq shell-file-name "bash")
    (setq explicit-bash.exe-args '("--noediting" "--login" "-i"))
    (setenv "SHELL" shell-file-name)
    (add-hook 'comint-output-filter-functions 'comint-strip-ctrl-m))
#+END_SRC

* Navigating
** Uniquify
Ensure that buffers have unique file names
#+BEGIN_SRC emacs-lisp
(use-package uniquify
  :ensure nil
  :config
  (setq uniquify-buffer-name-style 'forward))
#+END_SRC
** Dired+
#+BEGIN_SRC emacs-lisp
(use-package dired+
  :config
  (setq dired-dwim-target t)
  (setq dired-recursive-copies `always))

#+END_SRC
** Recentf
Turn on recent file mode so that you can more easily switch to recently edited files when you first start emacs
#+BEGIN_SRC emacs-lisp
(use-package recentf
  :config
  (setq recentf-save-file (concat user-emacs-directory ".recentf"))
  (recentf-mode 1)
  (setq recentf-max-menu-items 40))
#+END_SRC
** Projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :commands
    (projectile-find-file projectile-switch-project)
    :diminish
    (projectile-mode)
    :config
    (progn
      (setq projectile-completion-system 'ivy)
      (setq projectile-enable-caching t)))
#+END_SRC
** Minibuffer completion
As Stolen from http://cestlaz.github.io/posts/using-emacs-6-swiper/ (January 10, 2017) 
it looks like counsel is a requirement for swiper
*** Ivy
#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :hook (after-init . ivy-mode)
    :config
    (progn
      (setq ivy-use-virtual-buffers t)
      (setq ivy-initial-inputs-alist nil)
      (projectile-global-mode)
      (counsel-mode)))
#+END_SRC
*** Counsel
#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :after ivy
    :init
    (progn
      (setq counsel-grep-base-command
            "rg -i -M 120 --no-heading --line-number --color never '%s' %s"))
    :bind
    (("M-x" . counsel-M-x)
      ("C-x C-f" . counsel-find-file)
      ("C-c p f" . counsel-projectile-find-file)
      ("C-c p d" . counsel-projectile-find-dir)
      ("C-c p p" . counsel-projectile-switch-project)
      ("<f1> f" . counsel-describe-function)
      ("<f1> v" . counsel-describe-variable)
      ("<f1> l" . counsel-load-library)
      ("<f2> i" . counsel-info-lookup-symbol)
      ("<f2> u" . counsel-unicode-char)
      ("C-c k" . counsel-rg)))
#+END_SRC
*** Counsel-projectile
Normally preface should automatically be set by the package, but recently (Mon Aug 13, 2018), I've found projectile has changed their key mapping (https://github.com/bbatsov/projectile/commit/9c6e9813abec6e067c659e9107bf356086a95e04), and I need to handle this myself or until counsel projectile handles this for me ala https://github.com/ericdanan/counsel-projectile/pull/92.
#+BEGIN_SRC emacs-lisp
  (use-package counsel-projectile
    :after projectile
    :preface (setq projectile-keymap-prefix (kbd "C-c p"))
    :commands (counsel-projectile-switch-project counsel-projectile-find-file counsel-projectile-find-dir))
#+END_SRC
*** swiper
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :after ivy
    :bind ("C-s" . swiper))
#+END_SRC
** Treemacs
#+BEGIN_SRC emacs-lisp
  (use-package treemacs
    :config
    (progn
      (setq treemacs-follow-after-init          t
            treemacs-width                      35
            treemacs-indentation                2
            treemacs-git-integration            t
            treemacs-collapse-dirs              3
            treemacs-silent-refresh             nil
            treemacs-change-root-without-asking nil
            treemacs-sorting                    'alphabetic-desc
            treemacs-show-hidden-files          t
            treemacs-never-persist              nil
            treemacs-is-never-other-window      nil
            treemacs-goto-tag-strategy          'refetch-index)
      (treemacs-follow-mode t)
      (treemacs-filewatch-mode t))
    :bind
    (:map global-map
          ([f8]        . treemacs-toggle)
          ("<C-M-tab>" . treemacs-toggle)
          ("M-0"       . treemacs-select-window)
          ("C-c 1"     . treemacs-delete-other-windows)))
#+END_SRC
** Treemacs Pojectile
#+BEGIN_SRC emacs-lisp
  (use-package treemacs-projectile
    :config
    (setq treemacs-header-function #'treemacs-projectile-create-header))
#+END_SRC
** Avy
Navigate a buffer by visible characters
As Stolen from http://cestlaz.github.io/posts/using-emacs-7-avy/ (January 10, 2017)
#+BEGIN_SRC emacs-lisp
(use-package avy
  :bind ("C-c s" . avy-goto-char))
#+END_SRC
* Editing
General config to make editing text feel nice
** Multiple Cursors
Thank you Magnar Sveen!
I've put this at the top, because I use this almost everyday and wish it existed in more places.
#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :bind
  (("C->" . mc/mark-next-like-this)
   ("C-<" . mc/mark-previous-like-this)
   ("C-c C-<" . mc/mark-all-like-this)
   ("<s-mouse-1>" . mc/add-cursor-on-click))
  :commands (mc/mark-next-like-this mc/mark-previous-like-this mc/mark-all-like-this))
#+END_SRC

** Newline and indent
#+BEGIN_SRC emacs-lisp
  (define-key global-map (kbd "RET") 'newline-and-indent)
#+END_SRC
** Truncate lines
#+BEGIN_SRC emacs-lisp
(set-default 'truncate-lines t)
#+END_SRC
** Highlight current line
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode 1)
#+END_SRC
** Highlight matching parens
#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
#+END_SRC
** No tabs
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC
** Set base indent
#+BEGIN_SRC emacs-lisp
(setq tab-width 2)
#+END_SRC

** Save place in file
Remember where point was when I come back to a file
#+BEGIN_SRC emacs-lisp
(save-place-mode 1)
;; keep track of saved places in ~/.emacs.d/places
(setq save-place-file (concat user-emacs-directory "places"))
#+END_SRC
** Comment or Uncomment region
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-;") 'comment-or-uncomment-region)
#+END_SRC
** Parens Balancing
#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :hook (prog-mode . smartparens-mode)
    :bind (:map smartparens-mode-map
            ("C-)" . sp-forward-slurp-sexp)
            ("C-(" . sp-backward-slurp-sexp)
            ("C-}" . sp-forward-barf-sexp)
            ("C-{" . sp-backward-barf-sexp))
    :config
    (setq sp-escape-wrapped-region nil))
#+END_SRC
** Hungry Delete
#+BEGIN_SRC emacs-lisp
  (use-package hungry-delete
    :hook (prog-mode . global-hungry-delete-mode))
#+END_SRC

** Code Folding
#+BEGIN_SRC emacs-lisp
(use-package origami
  :bind ("C-s-<tab>" . origami-recursively-toggle-node)
  :hook (prog-mode . origami-mode))
#+END_SRC
** Dash At Point
Open up the program dash
#+BEGIN_SRC emacs-lisp
  (use-package dash-at-point
    :bind
    (("C-c d" . dash-at-point)
     ("C-c e" . dash-at-point-with-docset))
    :config
    (add-to-list 'dash-at-point-mode-alist '(ruby-mode . ("ruby" "rails")))
    (add-to-list 'dash-at-point-mode-alist '(clojurescript-mode ("clojure")))
    (add-to-list 'dash-at-point-mode-alist '(clojure-mode ("clojure"))))
#+END_SRC
** Undo-tree
Easily navigate buffer state through a UI helper
#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :demand t
  :config
  (global-undo-tree-mode))
#+END_SRC

** Backups
Emacs can automatically create backup files. This tells Emacs to put all backups in ~/.emacs.d/backups. More [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Backup-Files.html][info]].
#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist `(("." . ,(concat user-emacs-directory
                                                 "backups"))))
  (setq auto-save-default nil)
#+END_SRC
** Whitespace
Emacs doesn’t handle trailing spaces or anything like that very well by default, it’s far too aggressive for my tastes, so we’ll use ws-butler to fix this.
#+BEGIN_SRC emacs-lisp
  (use-package ws-butler
    :commands (ws-butler-global-mode)
    :hook (after-init . (lambda () (ws-butler-global-mode 1))))
#+END_SRC

* Syntax and Error checking
** Flycheck pos-tip
Load this before we load Flycheck
#+BEGIN_SRC emacs-lisp
(use-package flycheck-pos-tip)
#+END_SRC
** Flycheck
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :after flycheck-pos-tip
  :demand t
  :config
  (progn
    (global-flycheck-mode)
    (setq flycheck-check-syntax-automatically '(save mode-enabled))
    (setq flycheck-standard-error-navigation nil)
    (when 'display-graphic-p (selected-frame)
      (eval-after-load 'flycheck
      (flycheck-pos-tip-mode)))))
#+END_SRC

* Code Completion
** Semantic
#+BEGIN_SRC emacs-lisp
(use-package semantic 
  :config
  (semantic-mode 1)
  (global-semanticdb-minor-mode 1)
  (global-semantic-idle-scheduler-mode 1))
#+END_SRC
** Company
#+BEGIN_SRC emacs-lisp
  (use-package company
    :commands (global-company-mode)
    :bind
    (;;("C-<tab>" . company-capf)
     :map company-mode-map
     (("M-h" . company-quickhelp-manual-begin)))
    :init
    (add-hook 'after-init-hook 'global-company-mode)
    :config
    (progn
      (setq company-idle-delay 0.3)
      (setq company-frontends
            '(company-pseudo-tooltip-unless-just-one-frontend
              company-preview-frontend
              company-echo-metadata-frontend))
      (setq company-auto-complete t)
      (setq company-tooltip-align-annotations t)))
#+END_SRC
** LSP-Mode
#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode)
#+END_SRC
*** Company-LSP
#+BEGIN_SRC emacs-lisp
  (use-package company-lsp
    :after (company lsp-mode)
    :init (push 'company-lsp company-backends)
    :config
    (setq company-lsp-cache-candidates 'auto)
    ;;(setq company-lsp-async t)
    )
#+END_SRC
*** lsp-ui
#+BEGIN_SRC emacs-lisp
  (use-package lsp-ui
    :init
    (add-hook 'lsp-mode-hook #'lsp-ui-mode))
#+END_SRC
* Setup
Major mode customizations
** CSS/LESS/SASS
*** Rainbow mode
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :hook ((css-mode . rainbow-mode)
         (less-mode . rainbow-mode)))
#+END_SRC
*** Sass mode
#+BEGIN_SRC emacs-lisp
  (use-package sass-mode
    :mode "\\.sass\\'")
#+END_SRC

** C/C++
*** Add hooks and customizations
#+BEGIN_SRC emacs-lisp
  (progn ; C mode hook
    (add-hook 'c-mode-hook 'flycheck-mode)
    (add-hook 'c-mode-hook 'semantic-mode)
    (add-hook 'c-mode-hook 'ycmd-mode)
    (add-hook 'c-mode-hook 'counsel-gtags-mode)
    (add-hook 'c++-mode-hook 'counsel-gtags-mode)
    (add-hook 'c-mode-hook 'c-turn-on-eldoc-mode))

  (eval-after-load 'c-mode '(setq-local eldoc-documentation-function #'ggtags-eldoc-function))

  (setq-default c-basic-offset 2)
#+END_SRC

*** c-eldoc
#+BEGIN_SRC emacs-lisp
(use-package c-eldoc)
#+END_SRC

*** counsel-gtags
#+BEGIN_SRC emacs-lisp
  (use-package counsel-gtags
    :bind (("M-," . counsel-gtags-find-definition))
    :config
    (setq counsel-gtags-auto-update t))
#+END_SRC
*** ggtags
#+BEGIN_SRC emacs-lisp
(use-package ggtags
  :config
  (add-hook 'c-common-mode-hook 'ggtags-mode))
#+END_SRC
** Lisp
*** paredit
#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :commands (paredit-mode)
    :hook ((common-lisp-mode . (lambda () (enable-paredit)))
           (scheme-mode . (lambda () (enable-paredit)))
           (lisp-mode . (lambda () (enable-paredit)))))
#+END_SRC
*** lispy
We need lispy for some of the excellent bracket based navigation integrations with parinfer
#+BEGIN_SRC emacs-lisp
    (use-package lispy
     :defer nil)
#+END_SRC
*** parinfer
#+BEGIN_SRC emacs-lisp
  (use-package parinfer
    :commands (parinfer-mode)
    :bind (:map parinfer-mode-map
                (("C-t" . parinfer-toggle-mode)))
    :init (progn
            (require 'lispy)
            (setq parinfer-delay-invoke-threshold 6000)
            (setq parinfer-auto-switch-indent-mode t)
            (setq parinfer-extensions
                  '(defaults       ; should be included.
                     pretty-parens  ; different paren styles for different modes.
                     paredit        ; Introduce some paredit commands.
                     smart-tab      ; C-b & C-f jump positions and smart shift with tab & S-tab.
                     lispy
                     smart-yank))))   ; Yank behavior depend on mode
#+END_SRC

*** eldoc
#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :ensure t
    :config
    (eldoc-add-command
     'paredit-backward-delete
     'paredit-close-round)
    (global-eldoc-mode))
#+END_SRC
*** Slime 
#+BEGIN_SRC emacs-lisp
  (use-package slime
    :ensure t
    :init
    (add-hook 'lisp-mode-hook 'slime-mode)
    (add-hook 'lisp-mode-hook (lambda () (with-current-buffer (buffer-name)
                                           (let (old-window selected-window)
                                             (slime)
                                             (delete-other-windows old-window)
                                             (window-buffer old-window))))))
#+END_SRC
*** slime-company
#+BEGIN_SRC emacs-lisp
  (use-package slime-company
    :after slime
    :config
    (setq slime-contribs '(slime-fancy
                           slime-autodoc)))
#+END_SRC
*** lisp-mode
#+BEGIN_SRC emacs-lisp
  (use-package lisp-mode
    :ensure nil
    :config
    (setq inferior-lisp-program (executable-find "sbcl")))
#+END_SRC
** Elisp
*** elisp-mode
#+BEGIN_SRC emacs-lisp
    (use-package elisp-mode
      :ensure nil
      :init
      (add-hook 'emacs-lisp-mode-hook (lambda () (enable-paredit))))
#+END_SRC

** Clojure
*** Flycheck-joker
#+BEGIN_SRC emacs-lisp
  (use-package flycheck-joker
    :init
    (require 'flycheck-joker))
#+END_SRC
*** clj-refactor
#+BEGIN_SRC emacs-lisp

  ;; clojure refactor library
  ;; https://github.com/clojure-emacs/clj-refactor.el
  (use-package clj-refactor
    :after clojure-mode
    :config (progn (setq cljr-suppress-middleware-warnings t)
                   (add-hook 'clojure-mode-hook (lambda ()
                                                  (clj-refactor-mode 1)
                                                  (cljr-add-keybindings-with-prefix "C-c C-m")))))
#+END_SRC
*** Kibit
#+BEGIN_SRC emacs-lisp
(use-package kibit-helper)
#+END_SRC
*** clojure-mode
#+BEGIN_SRC emacs-lisp
  (use-package clojure-mode
    :mode (("\\.clj\\'" . clojure-mode)
           ( "\\.cljs\\'" . clojurescript-mode))
    :init
    (progn
      (add-hook 'clojure-mode-hook (lambda () (enable-parinfer)))
      (add-hook 'clojure-mode-hook 'flycheck-mode)
      (add-hook 'clojure-mode-hook 'cider-mode)
      (add-hook 'clojure-mode-hook 'eldoc-mode)
      (add-hook 'clojure-mode-hook 'subword-mode))
    :config
    (progn
      (add-to-list 'auto-mode-alist '("\\.edn$" . clojure-mode))
      (add-to-list 'auto-mode-alist '("\\.boot$" . clojure-mode))
      (setq inferior-lisp-program "lein repl")
      (font-lock-add-keywords
       nil
       '(("(\\(facts?\\)"
          (2 font-lock-keyword-face))
         ("(\\(background?\\)"
          (2 font-lock-keyword-face))))
      (electric-pair-mode)
      (setq define-clojure-indent 2)))
#+END_SRC

Clojure mode also supports extra font locking(for syntax highlighting), but I have noticed that this causes performance issues in large and complicated clojure files (which I have been playing a lot with lately), so I have turned this feature off.
#+BEGIN_SRC emacs-lisp :tangle
(require 'clojure-mode-extra-font-locking)
#+END_SRC

*** Cider
A REPL for Clojure and nrepl for ClojureScript
#+BEGIN_SRC emacs-lisp
  (use-package cider
    :hook ((clojure-mode . cider-mode)
           (clojurescript-mode . cider-mode))
    :commands (cider-jack-in cider-jack-in-clojurescript)
    :config
    (progn
      ;; REPL related stuff
      ;; REPL history file
      (setq cider-repl-history-file "~/.emacs.d/cider-history")
      ;; nice pretty printing

      (setq cider-repl-use-pretty-printing t)
      ;; nicer font lock in REPL

      (setq cider-repl-use-clojure-font-lock t)
      ;; result prefix for the REPL

      (setq cider-repl-result-prefix ";; => ")
      ;; never ending REPL history

      (setq cider-repl-wrap-history t)

      ;; looong history
      (setq cider-repl-history-size 3000)
      ;; eldoc for clojure

      (add-hook 'cider-mode-hook #'eldoc-mode)

      ;; error buffer not popping up
      (setq cider-show-error-buffer nil)

      ;; go right to the REPL buffer when it's finished connecting
      (setq cider-repl-pop-to-buffer-on-connect nil)

      ;; company mode for completion
      (add-hook 'cider-repl-mode-hook #'company-mode)
      (add-hook 'cider-mode-hook #'company-mode)
      ;; key bindings
      ;; these help me out with the way I usually develop web apps
      (defun cider-refresh ()
        (interactive)
        (cider-interactive-eval (format "(user/reset)")))
      (define-key clojure-mode-map (kbd "C-c C-v") 'cider-start-http-server)
      (define-key clojure-mode-map (kbd "C-M-r") 'cider-refresh)
      (define-key clojure-mode-map (kbd "C-c u") 'cider-user-ns)
      (define-key cider-mode-map (kbd "C-c u") 'cider-user-ns)))
#+END_SRC
** JavaScript
Package inspired by https://emacs.cafe/emacs/javascript/setup/2017/04/23/emacs-setup-javascript.html
*** Tern
#+BEGIN_SRC emacs-lisp
  (use-package company-tern
    :bind
    ("M-." . nil)
    ("M-," . nil)
    :config
    (setq company-tooltip-align-annotations t)
    (setq company-tern-property-marker " <p>"))
#+END_SRC

*** REPL
#+BEGIN_SRC emacs-lisp
  (use-package indium
    :after js2-mode
    :commands (indium-launch)
    :config
    (progn
      (add-hook 'indium-update-script-source-hook
                (lambda (url)
                  (indium-eval (format "window.dispatchEvent(new CustomEvent('patch', {detail: {url: '%s'}}))"
                                       url))))
      (indium-interaction-mode)))
#+END_SRC
*** js2-Mode
#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :mode "\\.js\\'"
    :bind ("C-c l i" . indium-launch)
    :config
    (require 'indium)
    (add-hook 'js-mode-hook 'subword-mode)
    (add-hook 'html-mode-hook 'subword-mode)
    (add-hook 'js2-mode-hook #'js2-imenu-extras-mode)
    (add-hook 'js2-mode-hook #'js2-refactor-mode)
    (add-to-list 'company-backends 'company-indium-repl)
    (add-hook 'js2-mode-hook (lambda ()
                               (tern-mode)))
    (setq js-indent-level 2)
    (setq js2-basic-offset 2)
    (add-hook 'js-mode-hook #'indium-interaction-mode))
#+END_SRC
*** js2-refactor
#+BEGIN_SRC emacs-lisp
  (use-package js2-refactor
    :bind
    (:map js2-mode-map
          ("C-k" . js2r-kill))
    :config
    (define-key js2-mode-map (kbd "C-k") #'js2r-kill)
    (js2r-add-keybindings-with-prefix "C-c C-r"))
#+END_SRC
*** CoffeeScript
#+BEGIN_SRC emacs-lisp
  (use-package coffee-mode
    :mode "\\.coffee$"
    :config
    (add-to-list 'company-backends 'company-tern)
    (custom-set-variables '(coffee-tab-width 2))
    (add-hook 'coffee-mode-hook 'subword-mode)
    (add-hook 'coffee-mode-hook 'highlight-indentation-current-column-mode)
    (add-hook 'coffee-mode-hook
              (defun coffee-mode-newline-and-indent ()
                (define-key coffee-mode-map "\C-j" 'coffee-newline-and-indent)
                (setq coffee-cleanup-whitespace nil))))
#+END_SRC
** HTML
*** tagedit
#+BEGIN_SRC emacs-lisp
  (use-package tagedit)
#+END_SRC
*** sgml-mode
#+BEGIN_SRC emacs-lisp
  (use-package sgml-mode
    :after tagedit
    :config
    (require 'tagedit)
    (tagedit-add-paredit-like-keybindings)
    (add-hook 'html-mode-hook (lambda () (tagedit-mode 1))))
#+END_SRC
** Ruby
*** Yard
#+BEGIN_SRC emacs-lisp
  (use-package yard-mode
    :hook (ruby-mode . yard-mode))
#+END_SRC
*** rbenv
#+BEGIN_SRC emacs-lisp
  (use-package rbenv
    :hook (ruby-mode . global-rbenv-mode)
    :config
     (setq rbenv-installation-dir "/usr/local/bin/rbenv"))
#+END_SRC
*** Robe
#+BEGIN_SRC emacs-lisp
  (use-package robe
    :commands (robe-start)
    :config
    (push 'company-robe company-backends))
#+END_SRC

*** inf-ruby
#+BEGIN_SRC emacs-lisp
  (use-package inf-ruby
    :bind
    (:map inf-ruby-minor-mode-map
          (("C-c C-z" . run-ruby)
           ("C-c C-b" . ruby-send-buffer)))
    :config
    (progn
        (message "disabling company mode")
        (company-mode 0)
        (when (executable-find "pry")
          (add-to-list 'inf-ruby-implementations '("pry" . "pry"))
          (setq inf-ruby-default-implementation "pry"))))
#+END_SRC
*** ruby-mode
#+BEGIN_SRC emacs-lisp
    (use-package ruby-mode
      :after robe
      :mode "\\.rb\\'"
      :mode "Rakefile\\'"
      :mode "Gemfile\\'"
      :mode "Berksfile\\'"
      :mode "Vagrantfile\\'"
      :interpreter "ruby"
      :init
      (progn
        (setq ruby-indent-level 2
              ruby-indent-tabs-mode nil)
        (add-hook 'ruby-mode 'superword-mode))
      :config
      (robe-start))
#+END_SRC
** Rust
*** Flycheck-rust
#+BEGIN_SRC emacs-lisp :tangle
    (use-package flycheck-rust
      :commands (flycheck-rust-setup)
      :hook rust-mode)
#+END_SRC
*** lsp-rust
#+BEGIN_SRC emacs-lisp :tangle
  (use-package lsp-rust
    :init
    (progn
      (require 'lsp-rust)
      (setq RUSTC "~/.cargo/bin/rustc")
      (setq lsp-rust-rls-command '("rustup" "run" "nightly" "rls"))
      (add-hook 'rust-mode-hook #'lsp-rust-enable)))
  ;;      (setq lsp-rust-rls-command '("rustup" "run" "nightly" "rls" "RUST_BACKTRACE=1"))))
#+END_SRC
*** Rust-mode
#+BEGIN_SRC emacs-lisp :tangle
  (use-package rust-mode
      :mode "\\.rs\\'"
      :bind
      (:map rust-mode-map
            (([tab] . company-indent-or-complete-common)
             ("C-c <tab>" . rust-format-buffer)))
      :config
      (progn
        (setq rust-indent-offset 2)
        (electric-pair-mode 1)))
#+END_SRC

*** Eglot
#+BEGIN_SRC emacs-lisp
  (use-package eglot
    :bind (("M-." . xref-find-definitions)
           ("M-," . xref-pop-marker-stack))
    :init (require 'eglot))
#+END_SRC

*** Cargo
#+BEGIN_SRC emacs-lisp :tangle
(use-package cargo)
#+END_SRC
*** rust-playground
#+BEGIN_SRC emacs-lisp :tangle
  (use-package rust-playground)
#+END_SRC

*** Rustic
We need to remove rust-mode from auto-mode-alist because either Cargo or Rust-playground packages are causing rust-mode to shadow rustic-mode.
#+BEGIN_SRC emacs-lisp
  (use-package rustic
    :bind ("C-c r" . rustic-compile)
    :init (setq auto-mode-alist (delete '("\\.rs\\'" . rust-mode) auto-mode-alist))
    :mode ("\\.rs\\'" . rustic-mode)
    :config
    (progn
      (setq auto-mode-alist (delete '("\\.rs\\'" . rust-mode) auto-mode-alist))
      (setq rustic-format-on-save nil)
      (setq rustic-rls-pkg 'eglot)
      (setq rustic-indent-offset 2)
      (electric-pair-mode 1)))
#+END_SRC
** Go
*** Go Mode
#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :mode "\\.go\\'"
    :bind (:map go-mode-map
                (("M-." . 'godef-jump)
                 ("M-," . 'pop-tag-mark)))
    :config
    (progn
      (add-hook 'before-save-hook 'gofmt-before-save)))
#+END_SRC

** JSON
#+BEGIN_SRC emacs-lisp
    (use-package json-mode
      :mode "\\.json\\'"
      :config
      (setq js-indent-level 2))
#+END_SRC
** Docker
*** Dockerfile
#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode
    :mode "\\Dockerfile\\'")
#+END_SRC
*** Docker
#+BEGIN_SRC emacs-lisp
  (use-package docker
    :config
    (progn
      (setenv "DOCKER_TLS_VERIFY" "1")
      (setenv "DOCKER_HOST" "tcp://10.11.12.13:2376")
      (setenv "DOCKER_CERT_PATH" "/Users/justin/.docker/machine/machines/box")
      (setenv "DOCKER_MACHINE_NAME" "box")))
#+END_SRC
** Markdown
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :commands (markdown-mode gfm-mode)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init (setq markdown-command "multimarkdown"))
#+END_SRC
*** Flymd
Live preview of MarkDown
#+BEGIN_SRC emacs-lisp
  (use-package flymd
   :commands (flymd-flyit))
#+END_SRC
** Lua
*** lua-mode
#+BEGIN_SRC emacs-lisp
  (use-package lua-mode
    :mode ("\\.lua\\'")
    :config
    (add-to-list 'interpreter-mode-alist '("lua" . lua-mode)))
#+END_SRC
*** company-lua
Get limited autocompletion in Lua
#+BEGIN_SRC emacs-lisp :tangle
  (use-package company-lua)
#+END_SRC
** Powershell
#+BEGIN_SRC emacs-lisp
  (use-package powershell
    :mode "\\.ps\\'")
#+END_SRC
** Terraform
*** Terraform mode
#+BEGIN_SRC emacs-lisp
  (use-package terraform-mode
  :mode "\\.tf\\'" )
#+END_SRC
** YAML
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :defer t)
#+END_SRC

** SSH
#+BEGIN_SRC emacs-lisp
(use-package ssh-config-mode)
#+END_SRC
** Text modes
#+BEGIN_SRC emacs-lisp
(use-package rst
  :mode (("\\.txt$" . rst-mode)
         ("\\.rst$" . rst-mode)
         ("\\.rest$" . rst-mode)))
#+END_SRC

* Communication
** Slack
#+BEGIN_SRC emacs-lisp
  (use-package slack
    :commands (slack-start slack-register-team)
    :init
    (setq slack-buffer-emojify t) ;; if you want to enable emoji, default nil
    (setq slack-prefer-current-team t)
    :config
    (slack-register-team
     :name "personal"
     :default t
     :client-id (getenv "SLACK_CLIENT_ID")
     :client-secret (getenv "SLACK_CLIENT_SECRET")
     :token (getenv "SLACK_TOKEN")
     :subscribed-channels '(general))
    (slack-register-team
       :name "work"
       :default nil
       :client-id (getenv "SLACK_CLIENT_ID")
       :client-secret (getenv "SLACK_CLIENT_SECRET")
       :token (getenv "TIDAL_SLACK_TOKEN")
       :subscribed-channels '(general)))

    ;; (slack-register-team
    ;;  :name "test"
    ;;  :client-id "3333333333.77777777777"
    ;;  :client-secret "cccccccccccccccccccccccccccccccc"
    ;;  :token "xxxx-yyyyyyyyyy-zzzzzzzzzzz-hhhhhhhhhhh-llllllllll"
    ;;  :subscribed-channels '(hoge fuga)))

    (use-package alert
      :commands (alert)
      :init
      (setq alert-default-style 'osx-notifier))
#+END_SRC
* Misc
** Fuzzy matching
#+BEGIN_SRC emacs-lisp
  (use-package flx)
#+END_SRC
** Woman
#+BEGIN_SRC emacs-lisp
  (use-package woman
    :ensure nil
    :config
    (progn (setq woman-manpath
                (split-string (shell-command-to-string "man --path") ":" t "\n"))
          (autoload 'woman "woman"
            "Decode and browse a UN*X man page." t)
          (autoload 'woman-find-file "woman"
            "Find, decode and browse a specific UN*X man-page file." t)))
#+END_SRC
** ido-completing-read
#+BEGIN_SRC emacs-lisp
  (use-package ido-completing-read+)
#+END_SRC
** Asynchronous framework
#+BEGIN_SRC emacs-lisp
(use-package deferred)
#+END_SRC
** Profiling
*** Esup
#+BEGIN_SRC emacs-lisp
(use-package esup
  :commands (esup))
#+END_SRC
*** profiler
#+BEGIN_SRC emacs-lisp
  (use-package profiler
    :bind
    (("s-l" . profiler-start)
     ("s-r" . profiler-report)))
#+END_SRC
** dired+
#+BEGIN_SRC emacs-lisp
(use-package dired+)
#+END_SRC
** http client
#+BEGIN_SRC emacs-lisp
  (use-package restclient)
#+END_SRC
* Custom Functions
** Resize font size
Increases the fonts size across all buffers
#+BEGIN_SRC emacs-lisp
(defun font-name-replace-size (font-name new-size)
  (let ((parts (split-string font-name "-")))
    (setcar (nthcdr 7 parts) (format "%d" new-size))
    (mapconcat 'identity parts "-")))

(defun increment-default-font-height (delta)
  "Adjust the default font height by DELTA on every frame.
The pixel size of the frame is kept (approximately) the same.
DELTA should be a multiple of 10, in the units used by the
:height face attribute."
  (let* ((new-height (+ (face-attribute 'default :height) delta))
         (new-point-height (/ new-height 10)))
    (dolist (f (frame-list))
      (with-selected-frame f
        ;; Latest 'set-frame-font supports a "frames" arg, but
        ;; we cater to Emacs 23 by looping instead.
        (set-frame-font (font-name-replace-size (face-font 'default)
                                                new-point-height)
                        t)))
    (set-face-attribute 'default nil :height new-height)
    (message "default font size is now %d" new-point-height)))

(defun increase-default-font-height ()
  (interactive)
  (increment-default-font-height 10))

(defun decrease-default-font-height ()
  (interactive)
  (increment-default-font-height -10))

(global-set-key (kbd "C-M-=") 'increase-default-font-height)
(global-set-key (kbd "C-M--") 'decrease-default-font-height)
#+END_SRC
** Scroll the buffer
The exact same functionality VIM has for C-e and C-y in normal mode:
[[https://github.com/anler/.emacs.d-literate/blob/master/README.org#scroll-the-buffer][stolen from here]]
#+BEGIN_SRC emacs-lisp :tangle
(defun scroll-up-one-line-command ()
  "Scroll text of selected window upward 1 line."
  (interactive)
  (scroll-up-command 1)
  (next-line))

(defun scroll-down-one-line-command ()
  "Scroll text of selected window downward 1 line."
  (interactive)
  (scroll-down-command 1)
  (previous-line))
#+END_SRC

And the same but without leaving the current window:
#+BEGIN_SRC emacs-lisp :tangle
(defun scroll-up-one-line-other-window ()
  "Scroll other window one line up"
  (interactive)
  (scroll-other-window 1))

(defun scroll-down-one-line-other-window ()
  "Scroll other window one line down"
  (interactive)
  (scroll-other-window -1))
#+END_SRC
** Tangle and Compile init file
#+BEGIN_SRC emacs-lisp
  (defun my/tangle-dotfiles ()
    "If the current file is this file, the code blocks are tangled"
    (when (equal (buffer-file-name) (expand-file-name "~/.emacs.d/README.org"))
      (org-babel-tangle nil (expand-file-name "~/.emacs.d/init.el"))))
      ;;(byte-compile-file "~/.emacs.d/init.el")
  (add-hook 'after-save-hook #'my/tangle-dotfiles)
#+END_SRC

** Run Current File
#+BEGIN_SRC emacs-lisp
  (defun xah-run-current-file ()
        "Execute the current file.
      For example, if the current buffer is the file x.py, then it'll call 「python x.py」 in a shell.
      The file can be Emacs Lisp, PHP, Perl, Python, Ruby, JavaScript, Bash, Ocaml, Visual Basic, TeX, Java, Clojure.
      File suffix is used to determine what program to run.

      If the file is modified or not saved, save it automatically before run.

      URL `http://ergoemacs.org/emacs/elisp_run_current_file.html'
      version 2016-01-28"
        (interactive)
        (let* ((-suffix-map
               ;; (‹extension› . ‹shell program name›)
               `(("php" . "php")
                 ("pl" . "perl")
                 ("py" . "python")
                 ("py3" . ,(if (string-equal system-type "windows-nt") "c:/Python32/python.exe" "python3"))
                 ("rb" . "ruby")
                 ("go" . "go run")
                 ("js" . "node") ; node.js
                 ("sh" . "bash")
                 ("clj" . "java -cp /home/xah/apps/clojure-1.6.0/clojure-1.6.0.jar clojure.main")
                 ("rkt" . "racket")
                 ("ml" . "ocaml")
                 ("vbs" . "cscript")
                 ("tex" . "pdflatex")
                 ("latex" . "pdflatex")
                 ("java" . "javac")))
              -fname
              -fSuffix
              -prog-name
              -cmd-str)

          (when (null (buffer-file-name)) (save-buffer))
          (when (buffer-modified-p) (save-buffer))

          (setq -fname (buffer-file-name))
          (setq -fSuffix (file-name-extension -fname))
          (setq -prog-name (cdr (assoc -fSuffix -suffix-map)))
          (setq -cmd-str (concat -prog-name " \""   -fname "\""))

          (cond
           ((string-equal -fSuffix "el") (load -fname))
           ((string-equal -fSuffix "java")
            (progn
              (shell-command -cmd-str "*xah-run-current-file output*" )
              (shell-command
               (format "java %s" (file-name-sans-extension (file-name-nondirectory -fname))))))
           (t (if -prog-name
                  (progn
                    (message "Running…")
                    (shell-command -cmd-str "*xah-run-current-file output*" ))
                (message "No recognized program file suffix for this file."))))))
    ;;  (global-set-key (kbd "s-r") 'xah-run-current-file)
#+END_SRC
** Eval and Replace
#+BEGIN_SRC emacs-lisp
  (defun eval-and-replace ()
    "Replace the preceding sexp with its value."
    (interactive)
    (backward-kill-sexp)
    (condition-case nil
        (prin1 (eval (read (current-kill 0)))
               (current-buffer))
      (error (message "Invalid expression")
             (insert (current-kill 0)))))

  (global-unset-key (kbd "C-x C-e"))
  (global-set-key (kbd "C-x C-e") 'eval-and-replace)
#+END_SRC
** Replace tabs
#+BEGIN_SRC emacs-lisp
  ;; use 4 spaces for tabs
  (defun die-tabs ()
    (interactive)
    (set-variable 'tab-width 2)
    (mark-whole-buffer)
    (untabify (region-beginning) (region-end))
    (keyboard-quit))
#+END_SRC

** Find unused functions in JavaScript
#+BEGIN_SRC emacs-lisp
  (defun js2-unused--find-definitions ()
    ;; Reset the value before visiting the AST
    (setq js2-unused-definitions nil)
    (js2-visit-ast js2-mode-ast
                   #'js2-unused-visitor))
  (defun js2-unused--unqualified-name (name)
    "Return the local name of NAME.
  foo.bar.baz => baz"
    (save-match-data
      (if (string-match "\\.\\([^.]+\\)$" name)
          (match-string 1 name)
        name)))

  (defun js2-unused-visitor (node end-p)
    "Add NODE's name to `js2-unused-definitions` if it is a function."
    (unless end-p
      (cond
       ;; assignment to a function
       ((and (js2-assign-node-p node)
             (js2-function-node-p (js2-assign-node-right node)))
        (push (js2-node-string (js2-assign-node-left node)) js2-unused-definitions))
       ;; function declaration (skipping anonymous ones)
       ((js2-function-node-p node)
        (if-let* ((name (js2-function-name node)))
            (push name js2-unused-definitions))))
      t))
  (defun js2-unused-functions ()
    (interactive)
    ;; Make sure that JS2 has finished parsing the buffer
    (js2-mode-wait-for-parse
     (lambda ()
       ;; Walk the AST tree to find all function definitions
       (js2-unused--find-definitions)
       ;; Use xref-js2 to filter the ones that are not referenced anywhere
       (let ((unused (seq-filter (lambda (name)
                                   (null (xref-js2--find-references
                                          (js2-unused--unqualified-name name))))
                                 js2-unused-definitions)))
         ;; If there are unreferenced function, display a message
         (apply #'message (if unused
                              `("Unused functions in %s: %s "
                                ,(file-name-nondirectory buffer-file-name)
                                ,(mapconcat #'identity unused " "))
                            '("No unused function found")))))))
#+END_SRC
** Enable Paredit or Parinfer
#+BEGIN_SRC emacs-lisp
  (defun enable-paredit ()
    (turn-off-smartparens-mode)
    (paredit-mode))

  (defun enable-parinfer ()
    (turn-off-smartparens-mode)
    (parinfer-mode))

(defun enable-lispy ()
    (turn-off-smartparens-mode)
    (lispy-mode))
#+END_SRC
** Renema buffer and file
#+BEGIN_SRC elisp
;; source: http://steve.yegge.googlepages.com/my-dot-emacs-file
(defun rename-file-and-buffer (new-name)
  "Renames both current buffer and file it's visiting to NEW-NAME."
  (interactive "sNew name: ")
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not filename)
        (message "Buffer '%s' is not visiting a file!" name)
      (if (get-buffer new-name)
          (message "A buffer named '%s' already exists!" new-name)
        (progn
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil))))))
#+END_SRC

** Post from any buffer to Slack with Emacs

#+BEGIN_SRC emacs-lisp
(defun jb/slack-quote-region ()
    (with-temp-buffer
      (insert region)
      (goto-char 1)
      (while (> (point-max) (point))
        (beginning-of-line)
        (insert "> ")
        (forward-line 1))
      (buffer-string)))

(defun jb/decorate-text (text)
  (let* ((decorators '(("None" . (lambda (text) text))
                       ("Code"  . (lambda (text) (concat "```" text "```")))
                       ("Quote"  . (lambda (text) (jb/slack-quote-region text)))))
         (decoration (completing-read "Select decoration: "
                                      decorators
                                      nil
                                      t)))
    (funcall (cdr (assoc decoration decorators)) text)))

(defun jb/send-region-to-slack ()
  (interactive)
  (let* ((team (slack-team-select))
         (room (slack-room-select
                (cl-loop for team in (list team)
                         append (with-slots (groups ims channels) team
                                  (append ims groups channels))))))
    (slack-message-send-internal (jb/decorate-text (filter-buffer-substring
                                                    (region-beginning) (region-end)))
                                 (oref room id)
                                 team)))
#+END_SRC

** Turn back on file-name-handler-alist
#+BEGIN_SRC emacs-lisp
(setq file-name-handler-alist doom--file-name-handler-alist)
#+END_SRC

** Playground
#+BEGIN_SRC emacs-lisp :tangle
  ;; -*- lexical-binding: t -*-
  (require 'subr-x)
  (setq lexical-binding t)

  (defun ruby-version-parser (line)
    (car (split-string
          (cadr
           (split-string line))
          "p")))

  (defun elixir-version-parser (line)
    (cadr
     (split-string line)))

  (defun rustc-version-parser (line)
    (car
     (split-string
      (cadr
       (split-string line))
      "-")))

  (defun go-version-parser (line)
    (cadr
     (split-string
      (caddr
       (split-string
        line))
      "go")))

  (defun perl-version-parser (line)
    (string-trim
     (car
      (split-string
       (cadr
        (split-string line "("))
       ")"))
     "v"))

  (defun python-version-parser (line)
    (cadr
     (split-string line)))

  ;; (defun get-prog-version (prog arg callback)
  ;;   (let ((proc (start-process "doom-modeline-prog"
  ;;                              "doom-modeline-prog"
  ;;                              prog
  ;;                              arg))
  ;;         (parser callback))
  ;;     (set-process-filter proc (lambda (proc1 line)
  ;;                                (defvar old-buffer-query-functions kill-buffer-query-functions) ;; Store old query function
  ;;                                (setq kill-buffer-query-functions nil) ;; No need to query user when we kill this buffer and process
  ;;                                (kill-process proc1)
  ;;                                (kill-buffer "doom-modeline-prog")
  ;;                                (setq kill-buffer-query-functions old-buffer-query-functions) ;; let's restore everthing
  ;;                                (funcall parser line)))
  ;;     nil))

  ;; (get-prog-version "ruby" "--version" 'ruby-version-parser)

  ;; (get-prog-version "iex" "--version" 'elixir-version-parser)

  ;; (get-prog-version "rustc" "--version" 'rustc-version-parser)

  ;; (get-prog-version "go" "version" 'go-version-parser)

  ;; (get-prog-version "perl" "--version" 'perl-version-parser)

  ;; (get-prog-version "python" "--version" 'python-version-parser)

  ;; (get-prog-version "pipenv" "run python --version")

  ;; (ruby-parser "ruby 2.3.3p222 (2016-11-21 revision 56859) [x86_64-darwin16]")
  ;; (elixir-parser "IEx 1.7.4 (compiled with Erlang/OTP 21)")
#+END_SRC
